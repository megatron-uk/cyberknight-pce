#!/usr/bin/env python

"""
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.


injectScript.py
================
A script inserter for the PC-Engine game 'Cyber Knight'.

In order to run, it requires a headerless copy of the Cyber Knight ROM file
and a directory of 'patch' JSON files, as generated by extractScript.py

John Snowdon <john@target-earth.net>
"""

import os
import sys
import traceback
import getopt
import struct
import binascii
import json

try:
	import cStringIO as StringIO
except:
	print "cStringIO not available"
	import StringIO

######################################################
############ < User configuration > ##################
######################################################

# Holds all patch files
PATCH_FILES = {}

MISMATCH_OK = False

# Translation table loader
from Table import load_table

# Default values
from config import ROM_NAME, PATCH_DIR_NAME, PATCH_EXTENSION, OUT_ROM_NAME, TABLE_NAME
from config import OVERWRITE, VERBOSE
from config import SWITCH_MODE
from config import DAKUTEN_ALL, DAKUTEN, DAKUTEN_REPLACE

# Load the definitions of which ranges in the files to examine
from config import BYTES
from config import METHOD_SIMPLE, METHOD_CONTIGUOUS
from config import METHOD_1, METHOD_2, METHOD_3
from config import METHOD_1_OFFSET, METHOD_2_OFFSET, METHOD_3_OFFSET
from config import METHOD_1_TRAILING_BYTES, METHOD_2_TRAILING_BYTES, METHOD_3_TRAILING_BYTES

######################################################
############ < Code starts here > ####################
######################################################

def patch_file(patchfile, patch, romfile):
	"""
	Load, encode and apply a translation patch segment to a file.
	"""
	
	ttable = load_table()
	
	contiguous_patch = []
	contiguous_text = ""
	
	for patch_segment in patch["data"]["data"]:
		apply_patch = True
		patch_segment["trans_size"] = len(patch_segment["trans_text"]) + len(patch_segment["start_bytes"]) + len(patch_segment["end_bytes"])
		s = []
		if len(patch_segment["trans_text"]) == 0:
			#print "%s - Skipping zero-length translation - reusing untranslated string" % patch_segment["string_start"]
			for sb in patch_segment["start_bytes"]:
				contiguous_text += "<" + sb + ">"
			contiguous_text += patch_segment["raw_text"]			
			for b in patch_segment["raw"]:
				s.append(b)
			for eb in patch_segment["end_bytes"]:
				contiguous_text += "<" + eb + ">"
		else:
							
			FILE.seek(int(patch_segment["string_start"], 16), 0)
			s = []
			
			# Add start bytes
			for sb in patch_segment["start_bytes"]:
				s.append(sb)
				contiguous_text += "<" + sb + ">"
			
			# Encode main text
			encoded_string = encode_text(patch_segment["trans_text"], ttable)
			contiguous_text += patch_segment["trans_text"]
			for b in encoded_string:
				s.append(b)
				
			# Pad with switch bytes until long enough
			if patch["data"]["insert_method"] != METHOD_CONTIGUOUS:
				while (len(s) < (patch_segment["raw_size"] - len(patch_segment["end_bytes"]))):
					s.append(SWITCH_MODE)
				
			# Add end bytes
			for eb in patch_segment["end_bytes"]:
				s.append(eb)
				contiguous_text += "<" + eb + ">"
				
			if VERBOSE:
				if patch["data"]["insert_method"] != METHOD_CONTIGUOUS:
					print "---"
					print "Untranslated length: %s" % patch_segment["raw_size"]
					print "Translated length: %s header + %s body + %s end" % (len(patch_segment["start_bytes"]), len(encoded_string), len(patch_segment["end_bytes"]))
					print patch_segment["raw_text"]
					print patch_segment["trans_text"]
					#print encoded_string
					
			patch_len = len(s)
			
			# Is the patch the same size as the original string?
			if patch_len != patch_segment["raw_size"]:
				# No
				apply_patch = False
				# Are we allowing string size mismatching?
				if MISMATCH_OK:
					
					# Yes
					# Is the patch longer than the original?
					if patch_len > patch_segment["raw_size"]:
						# Yes
						# Are we inserting via the contiguous method?
						if patch["data"]["insert_method"] == METHOD_CONTIGUOUS:
							# Yes
							print "%s - Applying (%s bytes)" % (patch_segment["string_start"], patch_len)
							apply_patch = True
						else:
							# No
							print "%s - WARN! NOT Applying, string sizes are mismatched! (%s != %s) There are likely to be problems!" % (
								patch_segment["string_start"], patch_len, patch_segment["raw_size"]
							)
					else:
						apply_patch = True
						if VERBOSE:
							print "%s - INFO! Applying, padding with %s (%s != %s)" % (
								patch_segment["string_start"], SWITCH_MODE, patch_len, patch_segment["raw_size"]
							)
						else:
							print "%s - Applying (%s bytes)" % (patch_segment["string_start"], patch_len)
				else:
					# No
					# Are we patching via the contiguous method?
					if patch["data"]["insert_method"] != METHOD_CONTIGUOUS:
						# No
						print "%s - WARNING! Not applying, string size mismatch! (%s != %s)" % (
							patch_segment["string_start"], patch_segment["trans_size"], patch_segment["raw_size"]
						)					
						apply_patch = False
					else:
						# Yes
						apply_patch = True
			else:
				if patch["data"]["insert_method"] != METHOD_CONTIGUOUS:
					print "%s - Applying %s bytes" % (patch_segment["string_start"], patch_len)
					
		# Are we simple patching? i.e. a fixed number of characters?
		if patch["data"]["insert_method"] == METHOD_SIMPLE:
			if apply_patch:
				write_text(s)
		
		if patch["data"]["insert_method"] == METHOD_CONTIGUOUS:
			if apply_patch:
				contiguous_patch += s
			
	if patch["data"]["insert_method"] == METHOD_CONTIGUOUS:
		print "Contiguous patch method"
		available_space = int(patch["data"]["block_end"], 16) - int(patch["data"]["block_start"], 16)
		used_space = len(contiguous_patch)
		print "Available space: %s" % available_space
		print "Patch size: %s" % used_space
		if VERBOSE:
			print ""
			contiguous_text = contiguous_text.replace("<00>", "<00>\n")
			print contiguous_text
			print contiguous_patch
			print ""				
		if used_space > available_space:
			print "ERROR! Cannot use patch larger than available space!"
		else:		
			FILE.seek(int(patch["data"]["block_start"], 16))
			write_text(contiguous_patch)
	return True

def write_text(encoded_string):
	"""
	Write the encoded character list back as their literal hex equivalents back to the in-memory file.
	"""
	for hex_byte in encoded_string:
		FILE.write(binascii.unhexlify(hex_byte))
	return True

def encode_text(string, ttable):
	"""
	Encode a string using the translation table to set the hex equivalent of the given characters.
	"""
	encoded_as_hex = []
	pos = 0
	i = 0
	while i < len(string):
		s = string[i]
		s_found = False
		s_code = False
		s_byte = False
		# is this a left chevron?
		if (s == "<"):
			# yes - this might be a control byte
			s_byte = s
			# is there a matching right chevron?
			for extra_char in string[i + 1:-1]:
				s_byte += extra_char
				if extra_char == ">":
					s_code = True
					break
			if s_code:
				if VERBOSE:
					print "INFO: Got a control byte: %s" % s_byte
				# jump to the end pos within input string
				i = i + len(s_byte)
				
		if (s == "\n"):
			hex_byte = "02"
			encoded_as_hex.append(hex_byte.lower().encode('utf8'))
			s_found = True
			i += 1
		else:
			if s_code:
				match_s = s_byte
			else:
				match_s = s
			# Search for the matching hex code for this character to encode it
			for hex_byte in ttable.keys():				
				if match_s == ttable[hex_byte]["pre_shift"]:
					encoded_as_hex.append(hex_byte.lower().encode('utf8'))
					s_found = True
					i += 1
					break
			# If we didn't find it then just add the literal
			if ((s_found is False) and (s_code is True)) and (len(s_byte) == 4):
				print "WARNING! No lookup for control byte %s - adding %s" % (s_byte, s_byte[1:-1])
				encoded_as_hex.append(s_byte[1:-1].lower().encode('utf8'))
				s_found = True
				
		if s_found is False:
			print "WARNING! No lookup for <%s>" % s
			i += 1
		pos += 1
		
	return encoded_as_hex

######################################################
########## < Run-time code start here > ##############
######################################################

try:
	opts, args = getopt.getopt(sys.argv[1:], "hvt:i:d:o:fm")
except getopt.GetoptError as err:
	print err
	sys.exit(2)

print ""
print "injectScript.py - Script injector for Cyber Knight"
print "----------------"
print ""

for o, a in opts:
	if o == "-h":
		print "A tool which can inject translated patches (output generated by extractScript.py)"
		print "back in to the Cyber Knight rom file for the PC-Engine."
		print ""
		print "Options:"
		print "-h	Show help text"
		print "-v	Enable verbose output"
		print "-i	Input file name (e.g. 'Cyber Knight (J).pce')"
		print "-t	Translation file name (e.g. 'CyberKnightTranslation.csv')"
		print "-d	Directory containing translation patches (.json files) (e.g. './patches/')"
		print "-o	Output file name (e.g. 'Cyber Knight (E).pce')"
		print "-f	Force overwite of output file even if it already exists"
		print "-m	Attempt to patch file, even if translation string sizes are mismatched to originals."
		print ""
		print "Example:"
		print "injectScript.py -i 'Cyber Knight (J).pce' -t 'table.csv' -d './patches/' -o 'CyberEnglish.pce'"
		print ""
		sys.exit(0)
		
	if o == "-v":
		VERBOSE = True
		
	if o == "-i":
		ROM_NAME = a

	if o == "-d":
		PATCH_DIR_NAME = a

	if o == "-o":
		OUT_ROM_NAME = a
		
	if o == "-f":
		OVERWRITE = True
		
	if o == "-m":
		MISMATCH_OK = True
		
	if o == "-t":
		TABLE_NAME = a
		
#############################################
# Print configuration
#############################################

print "Configuration"
print "============="
print "Verbose: %s" % VERBOSE
print "Over-write: %s" % OVERWRITE
if os.path.isfile(ROM_NAME):
	print "Input ROM File: %s <- OK" % ROM_NAME
else:
	print "Input ROM File: %s <- ERROR, input file not found!" % ROM_NAME
	sys.exit(2)
	
if os.path.isfile(TABLE_NAME):
	print "Translation Table File: %s <- OK" % TABLE_NAME
else:
	print "Translation Table File: %s <- ERROR, translation table not found!" % TABLE_NAME
	sys.exit(2)
	
if os.path.isdir(PATCH_DIR_NAME):
	print "Patch Directory: %s <- OK" % PATCH_DIR_NAME
	for d in os.listdir(PATCH_DIR_NAME):
		if os.path.isfile(PATCH_DIR_NAME + "/" + d) and (d.endswith("json")):
			PATCH_FILES[d] = {}
	if len(PATCH_FILES.keys()) < 1:
		print "Patches Found: 0 <- ERROR, no patches found!"
		sys.exit(2)
	else:
		print "Patches Found: %s <- OK" % len(PATCH_FILES) 
		for d in PATCH_FILES.keys():
			try:
				PATCH_FILES[d]["json"] = open(PATCH_DIR_NAME + "/" + d).read()
				PATCH_FILES[d]["data"] = json.loads(PATCH_FILES[d]["json"])
				t = 0
				for b in PATCH_FILES[d]["data"]["data"]:
					if len(b["trans_text"]) > 0:
						t += 1
				print "- %16s : %4s strings : %4s translations" % (d, len(PATCH_FILES[d]["data"]["data"]), t)
			except Exception as e:
				print "- %s <- ERROR, not a valid JSON file" % d
				print e
else:
	print "Patch Directory: %s <- ERROR, directory not found!" % PATCH_DIR_NAME
	sys.exit(2)

print "Output File: %s" % OUT_ROM_NAME
print ""

#################################################
# Use each patch file in turn
#################################################
print "Applying Translation Patches"
print "============================"
FILE = StringIO.StringIO()
romfile = open(ROM_NAME).read()
FILE.write(romfile)
for f in PATCH_FILES.keys():
	print "================="
	print "Applying %s" % f
	print "-----------------"
	patch_file(f, PATCH_FILES[f], FILE) 
	print ""
	
FILE.seek(0, 0)
newfile = open(OUT_ROM_NAME, "wb")
newfile.write(FILE.read())
newfile.close()
